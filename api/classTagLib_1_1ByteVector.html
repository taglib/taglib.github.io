---
layout: api
title: "TagLib::ByteVector Class Reference (TagLib)"
header: "2.1.1 (TagLib::ByteVector Class Reference)"
---
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTagLib.html">TagLib</a></li><li class="navelem"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classTagLib_1_1ByteVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TagLib::ByteVector Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A byte vector.  
 <a href="classTagLib_1_1ByteVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tbytevector_8h_source.html">tbytevector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6e5b2614dacfc049b5b6e32063d4aa1" id="r_af6e5b2614dacfc049b5b6e32063d4aa1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#af6e5b2614dacfc049b5b6e32063d4aa1">ByteVector</a> ()</td></tr>
<tr class="separator:af6e5b2614dacfc049b5b6e32063d4aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8da8ca7d1cff849c684bb9c2189602" id="r_a2c8da8ca7d1cff849c684bb9c2189602"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2c8da8ca7d1cff849c684bb9c2189602">ByteVector</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1ByteVector.html#abd17238daa4fad5eae1ff421e550facd">size</a>, <a class="el" href="classTagLib_1_1List.html">char</a> value=0)</td></tr>
<tr class="separator:a2c8da8ca7d1cff849c684bb9c2189602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613e5467e1b582775f98eed1e2f6c1ef" id="r_a613e5467e1b582775f98eed1e2f6c1ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a613e5467e1b582775f98eed1e2f6c1ef">ByteVector</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>)</td></tr>
<tr class="separator:a613e5467e1b582775f98eed1e2f6c1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb5a6eef9127e15e0379dc246cdc56b" id="r_aedb5a6eef9127e15e0379dc246cdc56b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aedb5a6eef9127e15e0379dc246cdc56b">ByteVector</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> length)</td></tr>
<tr class="separator:aedb5a6eef9127e15e0379dc246cdc56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa286e2ae6447e55e85ef855838d10c96" id="r_aa286e2ae6447e55e85ef855838d10c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa286e2ae6447e55e85ef855838d10c96">ByteVector</a> (<a class="el" href="classTagLib_1_1List.html">char</a> <a class="el" href="classTagLib_1_1List.html">c</a>)</td></tr>
<tr class="separator:aa286e2ae6447e55e85ef855838d10c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d28f4aeb8c4410ec3b69cdf30faeb" id="r_ae69d28f4aeb8c4410ec3b69cdf30faeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae69d28f4aeb8c4410ec3b69cdf30faeb">ByteVector</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1ByteVector.html#a4c34171c209d7cec3d1e8db026016751">data</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> length)</td></tr>
<tr class="separator:ae69d28f4aeb8c4410ec3b69cdf30faeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cd4cd25e6b8fbd6a795005478b08e0" id="r_aa3cd4cd25e6b8fbd6a795005478b08e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa3cd4cd25e6b8fbd6a795005478b08e0">ByteVector</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1ByteVector.html#a4c34171c209d7cec3d1e8db026016751">data</a>)</td></tr>
<tr class="separator:aa3cd4cd25e6b8fbd6a795005478b08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db065f90a93a27b9901f028c217dce5" id="r_a1db065f90a93a27b9901f028c217dce5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a1db065f90a93a27b9901f028c217dce5">~ByteVector</a> ()</td></tr>
<tr class="separator:a1db065f90a93a27b9901f028c217dce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebed84d071c998033fc6fe11d99a053f" id="r_aebed84d071c998033fc6fe11d99a053f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aebed84d071c998033fc6fe11d99a053f">setData</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1List.html">s</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> length)</td></tr>
<tr class="separator:aebed84d071c998033fc6fe11d99a053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab108f81d9b73cac51abb074403df9cf8" id="r_ab108f81d9b73cac51abb074403df9cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab108f81d9b73cac51abb074403df9cf8">setData</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1ByteVector.html#a4c34171c209d7cec3d1e8db026016751">data</a>)</td></tr>
<tr class="separator:ab108f81d9b73cac51abb074403df9cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c34171c209d7cec3d1e8db026016751" id="r_a4c34171c209d7cec3d1e8db026016751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4c34171c209d7cec3d1e8db026016751">data</a> ()</td></tr>
<tr class="separator:a4c34171c209d7cec3d1e8db026016751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37b6271fb12aab19fe09ffd7dbc9559" id="r_ad37b6271fb12aab19fe09ffd7dbc9559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad37b6271fb12aab19fe09ffd7dbc9559">data</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ad37b6271fb12aab19fe09ffd7dbc9559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf8469daa604ad694d7edb3853ab19d" id="r_adaf8469daa604ad694d7edb3853ab19d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#adaf8469daa604ad694d7edb3853ab19d">mid</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> index, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> length=0xffffffff) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:adaf8469daa604ad694d7edb3853ab19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ab0d699d4fe9e8cd3755e24a96add9" id="r_a09ab0d699d4fe9e8cd3755e24a96add9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a09ab0d699d4fe9e8cd3755e24a96add9">at</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> index) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a09ab0d699d4fe9e8cd3755e24a96add9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeda385dc577ea9ae0e74523574ea5b" id="r_a4aeda385dc577ea9ae0e74523574ea5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4aeda385dc577ea9ae0e74523574ea5b">find</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">pattern</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>=0, <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">byteAlign</a>=1) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a4aeda385dc577ea9ae0e74523574ea5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7c56ac7e73f92857216a48268cf3c" id="r_a19f7c56ac7e73f92857216a48268cf3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a19f7c56ac7e73f92857216a48268cf3c">find</a> (<a class="el" href="classTagLib_1_1List.html">char</a> <a class="el" href="classTagLib_1_1List.html">c</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>=0, <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">byteAlign</a>=1) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a19f7c56ac7e73f92857216a48268cf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304d4533c8872e36edf461e03673c595" id="r_a304d4533c8872e36edf461e03673c595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a304d4533c8872e36edf461e03673c595">rfind</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">pattern</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>=0, <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">byteAlign</a>=1) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a304d4533c8872e36edf461e03673c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8870bacf3135251187c1fb892b65cad4" id="r_a8870bacf3135251187c1fb892b65cad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a8870bacf3135251187c1fb892b65cad4">containsAt</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">pattern</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">patternOffset</a>=0, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">patternLength</a>=0xffffffff) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a8870bacf3135251187c1fb892b65cad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e2161c1153bb0e55baa21f37fd29ac" id="r_ab7e2161c1153bb0e55baa21f37fd29ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab7e2161c1153bb0e55baa21f37fd29ac">startsWith</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">pattern</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ab7e2161c1153bb0e55baa21f37fd29ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6151b9aeb99db8c7c3a1db1a6c95803e" id="r_a6151b9aeb99db8c7c3a1db1a6c95803e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a6151b9aeb99db8c7c3a1db1a6c95803e">endsWith</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">pattern</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a6151b9aeb99db8c7c3a1db1a6c95803e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95998c3e30fb62fe27f8210809f961ec" id="r_a95998c3e30fb62fe27f8210809f961ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a95998c3e30fb62fe27f8210809f961ec">replace</a> (<a class="el" href="classTagLib_1_1List.html">char</a> <a class="el" href="classTagLib_1_1List.html">oldByte</a>, <a class="el" href="classTagLib_1_1List.html">char</a> <a class="el" href="classTagLib_1_1List.html">newByte</a>)</td></tr>
<tr class="separator:a95998c3e30fb62fe27f8210809f961ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3503a839af29bd3d440f29c36996f38e" id="r_a3503a839af29bd3d440f29c36996f38e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3503a839af29bd3d440f29c36996f38e">replace</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">pattern</a>, <a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">with</a>)</td></tr>
<tr class="separator:a3503a839af29bd3d440f29c36996f38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eda2b131368a3fda8cc68664993d41" id="r_a08eda2b131368a3fda8cc68664993d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a08eda2b131368a3fda8cc68664993d41">endsWithPartialMatch</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">pattern</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a08eda2b131368a3fda8cc68664993d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa498bc8b5347289e5d6ce2399cb668f5" id="r_aa498bc8b5347289e5d6ce2399cb668f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa498bc8b5347289e5d6ce2399cb668f5">append</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>)</td></tr>
<tr class="separator:aa498bc8b5347289e5d6ce2399cb668f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc3ceff066064f8dd7c43087476967" id="r_a27bc3ceff066064f8dd7c43087476967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a27bc3ceff066064f8dd7c43087476967">append</a> (<a class="el" href="classTagLib_1_1List.html">char</a> <a class="el" href="classTagLib_1_1List.html">c</a>)</td></tr>
<tr class="separator:a27bc3ceff066064f8dd7c43087476967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ff4774ef21f55713bf71695b1f7e5f" id="r_a32ff4774ef21f55713bf71695b1f7e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a32ff4774ef21f55713bf71695b1f7e5f">clear</a> ()</td></tr>
<tr class="separator:a32ff4774ef21f55713bf71695b1f7e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd17238daa4fad5eae1ff421e550facd" id="r_abd17238daa4fad5eae1ff421e550facd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abd17238daa4fad5eae1ff421e550facd">size</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:abd17238daa4fad5eae1ff421e550facd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9377cafe32051604eb1ad9c70ff5fa38" id="r_a9377cafe32051604eb1ad9c70ff5fa38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a9377cafe32051604eb1ad9c70ff5fa38">resize</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1ByteVector.html#abd17238daa4fad5eae1ff421e550facd">size</a>, <a class="el" href="classTagLib_1_1List.html">char</a> <a class="el" href="classTagLib_1_1List.html">padding</a>=0)</td></tr>
<tr class="separator:a9377cafe32051604eb1ad9c70ff5fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99848a9fbcb7b39e16866a881e2b115f" id="r_a99848a9fbcb7b39e16866a881e2b115f"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a99848a9fbcb7b39e16866a881e2b115f">begin</a> ()</td></tr>
<tr class="separator:a99848a9fbcb7b39e16866a881e2b115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706249a8e6457b6f8e3055ef33a3d278" id="r_a706249a8e6457b6f8e3055ef33a3d278"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a706249a8e6457b6f8e3055ef33a3d278">begin</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a706249a8e6457b6f8e3055ef33a3d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a70df9ae5146a67ea62805175127b7" id="r_a19a70df9ae5146a67ea62805175127b7"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a19a70df9ae5146a67ea62805175127b7">cbegin</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a19a70df9ae5146a67ea62805175127b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a1f28d1a51f7351733f2ef22090c34" id="r_a53a1f28d1a51f7351733f2ef22090c34"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a53a1f28d1a51f7351733f2ef22090c34">end</a> ()</td></tr>
<tr class="separator:a53a1f28d1a51f7351733f2ef22090c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3325190f7fb7a33246eb0e87e1e4ea70" id="r_a3325190f7fb7a33246eb0e87e1e4ea70"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3325190f7fb7a33246eb0e87e1e4ea70">end</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a3325190f7fb7a33246eb0e87e1e4ea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3df5528fc0f313ed96327ded5a2216" id="r_afc3df5528fc0f313ed96327ded5a2216"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#afc3df5528fc0f313ed96327ded5a2216">cend</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:afc3df5528fc0f313ed96327ded5a2216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b3cc8251bedb5bbb3c917d5b30ea93" id="r_a01b3cc8251bedb5bbb3c917d5b30ea93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">ReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a01b3cc8251bedb5bbb3c917d5b30ea93">rbegin</a> ()</td></tr>
<tr class="separator:a01b3cc8251bedb5bbb3c917d5b30ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285911c109f6727305e2b2b3a4452051" id="r_a285911c109f6727305e2b2b3a4452051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">ConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a285911c109f6727305e2b2b3a4452051">rbegin</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a285911c109f6727305e2b2b3a4452051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a15e7cab535f22c8107992c66789d7" id="r_a18a15e7cab535f22c8107992c66789d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">ReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a18a15e7cab535f22c8107992c66789d7">rend</a> ()</td></tr>
<tr class="separator:a18a15e7cab535f22c8107992c66789d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a912b3dee16e34975da5dce7de84965" id="r_a7a912b3dee16e34975da5dce7de84965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">ConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a7a912b3dee16e34975da5dce7de84965">rend</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a7a912b3dee16e34975da5dce7de84965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f47088aea751ba43df4f8f6b566e10b" id="r_a4f47088aea751ba43df4f8f6b566e10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4f47088aea751ba43df4f8f6b566e10b">isEmpty</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a4f47088aea751ba43df4f8f6b566e10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf244fad24bb966607e9cc418e97a99" id="r_abcf244fad24bb966607e9cc418e97a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abcf244fad24bb966607e9cc418e97a99">toUInt</a> (<a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:abcf244fad24bb966607e9cc418e97a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac366a9f43958a6a5f2d627ab251d025d" id="r_ac366a9f43958a6a5f2d627ab251d025d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ac366a9f43958a6a5f2d627ab251d025d">toUInt</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ac366a9f43958a6a5f2d627ab251d025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae477135de922ef0a5729e5b0981a1534" id="r_ae477135de922ef0a5729e5b0981a1534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae477135de922ef0a5729e5b0981a1534">toUInt</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> length, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ae477135de922ef0a5729e5b0981a1534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd80366f7c2ec2f04c9033b411fc28fc" id="r_afd80366f7c2ec2f04c9033b411fc28fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">short</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#afd80366f7c2ec2f04c9033b411fc28fc">toShort</a> (<a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:afd80366f7c2ec2f04c9033b411fc28fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0bfaa07cf19ac9332736ec0effa007" id="r_a5c0bfaa07cf19ac9332736ec0effa007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">short</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5c0bfaa07cf19ac9332736ec0effa007">toShort</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a5c0bfaa07cf19ac9332736ec0effa007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a71a86707473f3a6310f6dd1cdb4f1f" id="r_a2a71a86707473f3a6310f6dd1cdb4f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">short</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2a71a86707473f3a6310f6dd1cdb4f1f">toUShort</a> (<a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a2a71a86707473f3a6310f6dd1cdb4f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44e5b55a57e65336d068edf8fef4614" id="r_af44e5b55a57e65336d068edf8fef4614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">short</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#af44e5b55a57e65336d068edf8fef4614">toUShort</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:af44e5b55a57e65336d068edf8fef4614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade89536283f902a1e05624d283d63fb2" id="r_ade89536283f902a1e05624d283d63fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ade89536283f902a1e05624d283d63fb2">toLongLong</a> (<a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ade89536283f902a1e05624d283d63fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9fe629a10881d3d034bf6cbc3ee0d6" id="r_a1c9fe629a10881d3d034bf6cbc3ee0d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a1c9fe629a10881d3d034bf6cbc3ee0d6">toLongLong</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a1c9fe629a10881d3d034bf6cbc3ee0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caf04fa53db2ae5bc851cfe1250650c" id="r_a6caf04fa53db2ae5bc851cfe1250650c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a6caf04fa53db2ae5bc851cfe1250650c">toULongLong</a> (<a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a6caf04fa53db2ae5bc851cfe1250650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b175a93fd23a2ec2eb83abebe61b8f" id="r_ad4b175a93fd23a2ec2eb83abebe61b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad4b175a93fd23a2ec2eb83abebe61b8f">toULongLong</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> <a class="el" href="classTagLib_1_1List.html">offset</a>, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ad4b175a93fd23a2ec2eb83abebe61b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505752b163a2896ca700fd634a0b3d25" id="r_a505752b163a2896ca700fd634a0b3d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a505752b163a2896ca700fd634a0b3d25">toFloat32LE</a> (<a class="el" href="classTagLib_1_1List.html">size_t</a> <a class="el" href="classTagLib_1_1List.html">offset</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a505752b163a2896ca700fd634a0b3d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0a17258a7aeab6d9e61b211ff7816" id="r_a93f0a17258a7aeab6d9e61b211ff7816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a93f0a17258a7aeab6d9e61b211ff7816">toFloat32BE</a> (<a class="el" href="classTagLib_1_1List.html">size_t</a> <a class="el" href="classTagLib_1_1List.html">offset</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a93f0a17258a7aeab6d9e61b211ff7816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4785d204bc4dc9276312a57452fc8d4f" id="r_a4785d204bc4dc9276312a57452fc8d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4785d204bc4dc9276312a57452fc8d4f">toFloat64LE</a> (<a class="el" href="classTagLib_1_1List.html">size_t</a> <a class="el" href="classTagLib_1_1List.html">offset</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a4785d204bc4dc9276312a57452fc8d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfd1f2d5cf744e51301dc7fabe64c6" id="r_ac0cfd1f2d5cf744e51301dc7fabe64c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ac0cfd1f2d5cf744e51301dc7fabe64c6">toFloat64BE</a> (<a class="el" href="classTagLib_1_1List.html">size_t</a> <a class="el" href="classTagLib_1_1List.html">offset</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ac0cfd1f2d5cf744e51301dc7fabe64c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e1f54ec6d15596bb8ea4e9231a3472" id="r_a42e1f54ec6d15596bb8ea4e9231a3472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a42e1f54ec6d15596bb8ea4e9231a3472">toFloat80LE</a> (<a class="el" href="classTagLib_1_1List.html">size_t</a> <a class="el" href="classTagLib_1_1List.html">offset</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a42e1f54ec6d15596bb8ea4e9231a3472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049b730201793f8b55164190d43b73cc" id="r_a049b730201793f8b55164190d43b73cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a049b730201793f8b55164190d43b73cc">toFloat80BE</a> (<a class="el" href="classTagLib_1_1List.html">size_t</a> <a class="el" href="classTagLib_1_1List.html">offset</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a049b730201793f8b55164190d43b73cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aab8384d1177ef0dab15110ebc6bd7" id="r_ae4aab8384d1177ef0dab15110ebc6bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae4aab8384d1177ef0dab15110ebc6bd7">operator[]</a> (<a class="el" href="classTagLib_1_1List.html">int</a> index) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ae4aab8384d1177ef0dab15110ebc6bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad53a4d1c4c910302efa00734905b91" id="r_a3ad53a4d1c4c910302efa00734905b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">char</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3ad53a4d1c4c910302efa00734905b91">operator[]</a> (<a class="el" href="classTagLib_1_1List.html">int</a> index)</td></tr>
<tr class="separator:a3ad53a4d1c4c910302efa00734905b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65309a009805dc8950dbf723b5110e9" id="r_ad65309a009805dc8950dbf723b5110e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad65309a009805dc8950dbf723b5110e9">operator==</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ad65309a009805dc8950dbf723b5110e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ea62629d75e7953f5b19180bb4fdc7" id="r_a42ea62629d75e7953f5b19180bb4fdc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a42ea62629d75e7953f5b19180bb4fdc7">operator!=</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a42ea62629d75e7953f5b19180bb4fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba384bab1d09d3704122a581ee3377b" id="r_a9ba384bab1d09d3704122a581ee3377b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a9ba384bab1d09d3704122a581ee3377b">operator==</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1List.html">s</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a9ba384bab1d09d3704122a581ee3377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299387a9e31cc2ded9ab26118fc17a82" id="r_a299387a9e31cc2ded9ab26118fc17a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a299387a9e31cc2ded9ab26118fc17a82">operator!=</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1List.html">s</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a299387a9e31cc2ded9ab26118fc17a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbc23d77c36cd60cfa79e581ac5f5ce" id="r_a9dbc23d77c36cd60cfa79e581ac5f5ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a9dbc23d77c36cd60cfa79e581ac5f5ce">operator&lt;</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a9dbc23d77c36cd60cfa79e581ac5f5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ac33aa5028a1484c0f78767e295b1e" id="r_ae0ac33aa5028a1484c0f78767e295b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae0ac33aa5028a1484c0f78767e295b1e">operator&gt;</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ae0ac33aa5028a1484c0f78767e295b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00a9703a9536d65e0873fa31ff62035" id="r_ad00a9703a9536d65e0873fa31ff62035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad00a9703a9536d65e0873fa31ff62035">operator+</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>) <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:ad00a9703a9536d65e0873fa31ff62035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd41fc03493530af75f6b5cefacc6eb1" id="r_abd41fc03493530af75f6b5cefacc6eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abd41fc03493530af75f6b5cefacc6eb1">operator=</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>)</td></tr>
<tr class="separator:abd41fc03493530af75f6b5cefacc6eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bd70d0ae9c72fd6e768815c612d606" id="r_ad1bd70d0ae9c72fd6e768815c612d606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad1bd70d0ae9c72fd6e768815c612d606">operator=</a> (<a class="el" href="classTagLib_1_1List.html">char</a> <a class="el" href="classTagLib_1_1List.html">c</a>)</td></tr>
<tr class="separator:ad1bd70d0ae9c72fd6e768815c612d606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0cc06303dbb2d22ba2809b25fd5a67" id="r_a7f0cc06303dbb2d22ba2809b25fd5a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a7f0cc06303dbb2d22ba2809b25fd5a67">operator=</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1ByteVector.html#a4c34171c209d7cec3d1e8db026016751">data</a>)</td></tr>
<tr class="separator:a7f0cc06303dbb2d22ba2809b25fd5a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078537b51e7714e1616c5fba6a1a2ecf" id="r_a078537b51e7714e1616c5fba6a1a2ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a078537b51e7714e1616c5fba6a1a2ecf">swap</a> (<a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>) <a class="el" href="classTagLib_1_1List.html">noexcept</a></td></tr>
<tr class="separator:a078537b51e7714e1616c5fba6a1a2ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c38a1f57c66bc9ebf469335cbb0ad1b" id="r_a3c38a1f57c66bc9ebf469335cbb0ad1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3c38a1f57c66bc9ebf469335cbb0ad1b">toHex</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a3c38a1f57c66bc9ebf469335cbb0ad1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b42194375d3bf08131ad680b5078647" id="r_a6b42194375d3bf08131ad680b5078647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a6b42194375d3bf08131ad680b5078647">toBase64</a> () <a class="el" href="classTagLib_1_1List.html">const</a></td></tr>
<tr class="separator:a6b42194375d3bf08131ad680b5078647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8b8cc9274056ef65cdcfe026843cbfb8" id="r_a8b8cc9274056ef65cdcfe026843cbfb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> value, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>)</td></tr>
<tr class="separator:a8b8cc9274056ef65cdcfe026843cbfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162543bf4b280468a677799686178522" id="r_a162543bf4b280468a677799686178522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort</a> (<a class="el" href="classTagLib_1_1List.html">short</a> value, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>)</td></tr>
<tr class="separator:a162543bf4b280468a677799686178522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439ec22666f883d2ee2c60ab442a76b7" id="r_a439ec22666f883d2ee2c60ab442a76b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a439ec22666f883d2ee2c60ab442a76b7">fromUShort</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">short</a> value, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>)</td></tr>
<tr class="separator:a439ec22666f883d2ee2c60ab442a76b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b81a576453f38fb816294f1e77a76d" id="r_a51b81a576453f38fb816294f1e77a76d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a51b81a576453f38fb816294f1e77a76d">fromLongLong</a> (<a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a> value, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>)</td></tr>
<tr class="separator:a51b81a576453f38fb816294f1e77a76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0119a6cdef00b3343786f35bf1a6b7a" id="r_af0119a6cdef00b3343786f35bf1a6b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#af0119a6cdef00b3343786f35bf1a6b7a">fromULongLong</a> (<a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a> value, <a class="el" href="classTagLib_1_1List.html">bool</a> <a class="el" href="classTagLib_1_1List.html">mostSignificantByteFirst</a>=<a class="el" href="classTagLib_1_1List.html">true</a>)</td></tr>
<tr class="separator:af0119a6cdef00b3343786f35bf1a6b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e0045d245950a0b1e73f79bc3b6f7d" id="r_a75e0045d245950a0b1e73f79bc3b6f7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a75e0045d245950a0b1e73f79bc3b6f7d">fromFloat32LE</a> (<a class="el" href="classTagLib_1_1List.html">float</a> value)</td></tr>
<tr class="separator:a75e0045d245950a0b1e73f79bc3b6f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8776da15f1e921a9643a4b10c39ddec" id="r_ad8776da15f1e921a9643a4b10c39ddec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad8776da15f1e921a9643a4b10c39ddec">fromFloat32BE</a> (<a class="el" href="classTagLib_1_1List.html">float</a> value)</td></tr>
<tr class="separator:ad8776da15f1e921a9643a4b10c39ddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545dd80c5cff59a070b804d3d2bcc979" id="r_a545dd80c5cff59a070b804d3d2bcc979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a545dd80c5cff59a070b804d3d2bcc979">fromFloat64LE</a> (<a class="el" href="classTagLib_1_1List.html">double</a> value)</td></tr>
<tr class="separator:a545dd80c5cff59a070b804d3d2bcc979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86ed6c1ddef60bd2a1b3c099fba1982" id="r_ab86ed6c1ddef60bd2a1b3c099fba1982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab86ed6c1ddef60bd2a1b3c099fba1982">fromFloat64BE</a> (<a class="el" href="classTagLib_1_1List.html">double</a> value)</td></tr>
<tr class="separator:ab86ed6c1ddef60bd2a1b3c099fba1982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c77c48df4fd1096aa174ef09a938bbc" id="r_a0c77c48df4fd1096aa174ef09a938bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a0c77c48df4fd1096aa174ef09a938bbc">fromCString</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *<a class="el" href="classTagLib_1_1List.html">s</a>, <a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> length=0xffffffff)</td></tr>
<tr class="separator:a0c77c48df4fd1096aa174ef09a938bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b37359217aacf0c494a192129589c" id="r_a258b37359217aacf0c494a192129589c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a258b37359217aacf0c494a192129589c">fromBase64</a> (<a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;)</td></tr>
<tr class="separator:a258b37359217aacf0c494a192129589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aed0573f25ee917a40d6cd242b3115ae0" id="r_aed0573f25ee917a40d6cd242b3115ae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1List.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aed0573f25ee917a40d6cd242b3115ae0">detach</a> ()</td></tr>
<tr class="separator:aed0573f25ee917a40d6cd242b3115ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a36db251bf327d8f00dcee07367fd7cd5" id="r_a36db251bf327d8f00dcee07367fd7cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="taglib__export_8h.html#a869a58b518ef871f14a9b4ccfe86ecfb">TAGLIB_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a36db251bf327d8f00dcee07367fd7cd5">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="classTagLib_1_1List.html">s</a>, <a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;<a class="el" href="classTagLib_1_1List.html">v</a>)</td></tr>
<tr class="separator:a36db251bf327d8f00dcee07367fd7cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A byte vector. </p>
<p>This class provides an implicitly shared byte vector with some methods that are useful for tagging purposes. Many of the search functions are tailored to what is useful for finding tag related patterns in a data array. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af6e5b2614dacfc049b5b6e32063d4aa1" name="af6e5b2614dacfc049b5b6e32063d4aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e5b2614dacfc049b5b6e32063d4aa1">&#9670;&#160;</a></span>ByteVector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an empty byte vector. </p>

</div>
</div>
<a id="a2c8da8ca7d1cff849c684bb9c2189602" name="a2c8da8ca7d1cff849c684bb9c2189602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8da8ca7d1cff849c684bb9c2189602">&#9670;&#160;</a></span>ByteVector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a vector of size <em>size</em> with all values set to <em>value</em> by default. </p>

</div>
</div>
<a id="a613e5467e1b582775f98eed1e2f6c1ef" name="a613e5467e1b582775f98eed1e2f6c1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613e5467e1b582775f98eed1e2f6c1ef">&#9670;&#160;</a></span>ByteVector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that is a copy of <em>v</em>. </p>

</div>
</div>
<a id="aedb5a6eef9127e15e0379dc246cdc56b" name="aedb5a6eef9127e15e0379dc246cdc56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb5a6eef9127e15e0379dc246cdc56b">&#9670;&#160;</a></span>ByteVector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that is a copy of <em>v</em>. </p>

</div>
</div>
<a id="aa286e2ae6447e55e85ef855838d10c96" name="aa286e2ae6447e55e85ef855838d10c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa286e2ae6447e55e85ef855838d10c96">&#9670;&#160;</a></span>ByteVector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that contains <em>c</em>. </p>

</div>
</div>
<a id="ae69d28f4aeb8c4410ec3b69cdf30faeb" name="ae69d28f4aeb8c4410ec3b69cdf30faeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69d28f4aeb8c4410ec3b69cdf30faeb">&#9670;&#160;</a></span>ByteVector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> for up to <em>length</em> bytes. </p>

</div>
</div>
<a id="aa3cd4cd25e6b8fbd6a795005478b08e0" name="aa3cd4cd25e6b8fbd6a795005478b08e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cd4cd25e6b8fbd6a795005478b08e0">&#9670;&#160;</a></span>ByteVector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> up to the first null byte. This is particularly useful for constructing byte arrays from string constants.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if <em>data</em> is not null terminated. </dd></dl>

</div>
</div>
<a id="a1db065f90a93a27b9901f028c217dce5" name="a1db065f90a93a27b9901f028c217dce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db065f90a93a27b9901f028c217dce5">&#9670;&#160;</a></span>~ByteVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::~ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> instance. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27bc3ceff066064f8dd7c43087476967" name="a27bc3ceff066064f8dd7c43087476967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bc3ceff066064f8dd7c43087476967">&#9670;&#160;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends <em>c</em> to the end of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. </p>

</div>
</div>
<a id="aa498bc8b5347289e5d6ce2399cb668f5" name="aa498bc8b5347289e5d6ce2399cb668f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa498bc8b5347289e5d6ce2399cb668f5">&#9670;&#160;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends <em>v</em> to the end of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. </p>

</div>
</div>
<a id="a09ab0d699d4fe9e8cd3755e24a96add9" name="a09ab0d699d4fe9e8cd3755e24a96add9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ab0d699d4fe9e8cd3755e24a96add9">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">char</a> TagLib::ByteVector::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This essentially performs the same as <a class="el" href="classTagLib_1_1ByteVector.html#ae4aab8384d1177ef0dab15110ebc6bd7">operator[]()</a>, but instead of causing a runtime error if the index is out of bounds, it will return a null byte. </p>

</div>
</div>
<a id="a99848a9fbcb7b39e16866a881e2b115f" name="a99848a9fbcb7b39e16866a881e2b115f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99848a9fbcb7b39e16866a881e2b115f">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an Iterator that points to the front of the vector. </p>

</div>
</div>
<a id="a706249a8e6457b6f8e3055ef33a3d278" name="a706249a8e6457b6f8e3055ef33a3d278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706249a8e6457b6f8e3055ef33a3d278">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the front of the vector. </p>

</div>
</div>
<a id="a19a70df9ae5146a67ea62805175127b7" name="a19a70df9ae5146a67ea62805175127b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a70df9ae5146a67ea62805175127b7">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the front of the vector. </p>

</div>
</div>
<a id="afc3df5528fc0f313ed96327ded5a2216" name="afc3df5528fc0f313ed96327ded5a2216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3df5528fc0f313ed96327ded5a2216">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the back of the vector. </p>

</div>
</div>
<a id="a32ff4774ef21f55713bf71695b1f7e5f" name="a32ff4774ef21f55713bf71695b1f7e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ff4774ef21f55713bf71695b1f7e5f">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the data. </p>

</div>
</div>
<a id="a8870bacf3135251187c1fb892b65cad4" name="a8870bacf3135251187c1fb892b65cad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8870bacf3135251187c1fb892b65cad4">&#9670;&#160;</a></span>containsAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::containsAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>patternOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>patternLength</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if the vector contains the <em>pattern</em> starting at position <em>offset</em>. Optionally, if you only want to search for part of the pattern you can specify an offset within the pattern to start from. Also, you can specify to only check for the first <em>patternLength</em> bytes of <em>pattern</em> with the <em>patternLength</em> argument. </p>

</div>
</div>
<a id="a4c34171c209d7cec3d1e8db026016751" name="a4c34171c209d7cec3d1e8db026016751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c34171c209d7cec3d1e8db026016751">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">char</a> * TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the internal data structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>Care should be taken when modifying this data structure as it is easy to corrupt the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> when doing so. Specifically, while the data may be changed, its length may not be. </dd></dl>

</div>
</div>
<a id="ad37b6271fb12aab19fe09ffd7dbc9559" name="ad37b6271fb12aab19fe09ffd7dbc9559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37b6271fb12aab19fe09ffd7dbc9559">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> * TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the internal data structure which may not be modified. </p>

</div>
</div>
<a id="aed0573f25ee917a40d6cd242b3115ae0" name="aed0573f25ee917a40d6cd242b3115ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0573f25ee917a40d6cd242b3115ae0">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">void</a> TagLib::ByteVector::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is being shared via implicit sharing, do a deep copy of the data and separate from the shared members. This should be called by all non-const subclass members. </p>

</div>
</div>
<a id="a53a1f28d1a51f7351733f2ef22090c34" name="a53a1f28d1a51f7351733f2ef22090c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a1f28d1a51f7351733f2ef22090c34">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an Iterator that points to the back of the vector. </p>

</div>
</div>
<a id="a3325190f7fb7a33246eb0e87e1e4ea70" name="a3325190f7fb7a33246eb0e87e1e4ea70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3325190f7fb7a33246eb0e87e1e4ea70">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the back of the vector. </p>

</div>
</div>
<a id="a6151b9aeb99db8c7c3a1db1a6c95803e" name="a6151b9aeb99db8c7c3a1db1a6c95803e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6151b9aeb99db8c7c3a1db1a6c95803e">&#9670;&#160;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::endsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the vector ends with <em>pattern</em>. </p>

</div>
</div>
<a id="a08eda2b131368a3fda8cc68664993d41" name="a08eda2b131368a3fda8cc68664993d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eda2b131368a3fda8cc68664993d41">&#9670;&#160;</a></span>endsWithPartialMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::endsWithPartialMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for a partial match of <em>pattern</em> at the end of the vector. It returns the offset of the partial match within the vector, or -1 if the pattern is not found. This method is particularly useful when searching for patterns that start in one vector and end in another. When combined with <a class="el" href="classTagLib_1_1ByteVector.html#ab7e2161c1153bb0e55baa21f37fd29ac">startsWith()</a> it can be used to find a pattern that overlaps two buffers.</p>
<dl class="section note"><dt>Note</dt><dd>This will not match the complete pattern at the end of the string; use <a class="el" href="classTagLib_1_1ByteVector.html#a6151b9aeb99db8c7c3a1db1a6c95803e">endsWith()</a> for that. </dd></dl>

</div>
</div>
<a id="a19f7c56ac7e73f92857216a48268cf3c" name="a19f7c56ac7e73f92857216a48268cf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f7c56ac7e73f92857216a48268cf3c">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the char for <em>c</em> starting at <em>offset</em> and returns the offset. Returns <em>-1</em> if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a id="a4aeda385dc577ea9ae0e74523574ea5b" name="a4aeda385dc577ea9ae0e74523574ea5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aeda385dc577ea9ae0e74523574ea5b">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> for <em>pattern</em> starting at <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a id="a258b37359217aacf0c494a192129589c" name="a258b37359217aacf0c494a192129589c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258b37359217aacf0c494a192129589c">&#9670;&#160;</a></span>fromBase64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromBase64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decodes the base64 encoded byte vector.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a6b42194375d3bf08131ad680b5078647">toBase64()</a> </dd></dl>

</div>
</div>
<a id="a0c77c48df4fd1096aa174ef09a938bbc" name="a0c77c48df4fd1096aa174ef09a938bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c77c48df4fd1096aa174ef09a938bbc">&#9670;&#160;</a></span>fromCString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromCString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on the CString <em>s</em>. </p>

</div>
</div>
<a id="ad8776da15f1e921a9643a4b10c39ddec" name="ad8776da15f1e921a9643a4b10c39ddec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8776da15f1e921a9643a4b10c39ddec">&#9670;&#160;</a></span>fromFloat32BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat32BE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em> as an IEEE754 32-bit big-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a93f0a17258a7aeab6d9e61b211ff7816">toFloat32BE()</a> </dd></dl>

</div>
</div>
<a id="a75e0045d245950a0b1e73f79bc3b6f7d" name="a75e0045d245950a0b1e73f79bc3b6f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e0045d245950a0b1e73f79bc3b6f7d">&#9670;&#160;</a></span>fromFloat32LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat32LE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">float</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em> as an IEEE754 32-bit little-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a505752b163a2896ca700fd634a0b3d25">toFloat32LE()</a> </dd></dl>

</div>
</div>
<a id="ab86ed6c1ddef60bd2a1b3c099fba1982" name="ab86ed6c1ddef60bd2a1b3c099fba1982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86ed6c1ddef60bd2a1b3c099fba1982">&#9670;&#160;</a></span>fromFloat64BE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat64BE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">double</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em> as an IEEE754 64-bit big-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#ac0cfd1f2d5cf744e51301dc7fabe64c6">toFloat64BE()</a> </dd></dl>

</div>
</div>
<a id="a545dd80c5cff59a070b804d3d2bcc979" name="a545dd80c5cff59a070b804d3d2bcc979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545dd80c5cff59a070b804d3d2bcc979">&#9670;&#160;</a></span>fromFloat64LE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat64LE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">double</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em> as an IEEE754 64-bit little-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a4785d204bc4dc9276312a57452fc8d4f">toFloat64LE()</a> </dd></dl>

</div>
</div>
<a id="a51b81a576453f38fb816294f1e77a76d" name="a51b81a576453f38fb816294f1e77a76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b81a576453f38fb816294f1e77a76d">&#9670;&#160;</a></span>fromLongLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is <code>true</code>, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 00 00 01 == 0x0000000000000001 == 1, if <code>false</code>, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#ade89536283f902a1e05624d283d63fb2">toLongLong()</a> </dd></dl>

</div>
</div>
<a id="a162543bf4b280468a677799686178522" name="a162543bf4b280468a677799686178522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162543bf4b280468a677799686178522">&#9670;&#160;</a></span>fromShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">short</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 2 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is <code>true</code>, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 01 == 0x0001 == 1, if <code>false</code>, $01 00 == 0x0100 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#afd80366f7c2ec2f04c9033b411fc28fc">toShort()</a> </dd></dl>

</div>
</div>
<a id="a8b8cc9274056ef65cdcfe026843cbfb8" name="a8b8cc9274056ef65cdcfe026843cbfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8cc9274056ef65cdcfe026843cbfb8">&#9670;&#160;</a></span>fromUInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromUInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is <code>true</code>, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 00 00 01 == 0x00000001 == 1, if <code>false</code>, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#abcf244fad24bb966607e9cc418e97a99">toUInt()</a> </dd></dl>

</div>
</div>
<a id="af0119a6cdef00b3343786f35bf1a6b7a" name="af0119a6cdef00b3343786f35bf1a6b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0119a6cdef00b3343786f35bf1a6b7a">&#9670;&#160;</a></span>fromULongLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromULongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is <code>true</code>, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 00 00 01 == 0x0000000000000001 == 1, if <code>false</code>, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a6caf04fa53db2ae5bc851cfe1250650c">toULongLong()</a> </dd></dl>

</div>
</div>
<a id="a439ec22666f883d2ee2c60ab442a76b7" name="a439ec22666f883d2ee2c60ab442a76b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439ec22666f883d2ee2c60ab442a76b7">&#9670;&#160;</a></span>fromUShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">static</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromUShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">short</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 2 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is <code>true</code>, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 01 == 0x0001 == 1, if <code>false</code>, $01 00 == 0x0100 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a2a71a86707473f3a6310f6dd1cdb4f1f">toUShort()</a> </dd></dl>

</div>
</div>
<a id="a4f47088aea751ba43df4f8f6b566e10b" name="a4f47088aea751ba43df4f8f6b566e10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f47088aea751ba43df4f8f6b566e10b">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is empty.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#abd17238daa4fad5eae1ff421e550facd">size()</a> </dd></dl>

</div>
</div>
<a id="adaf8469daa604ad694d7edb3853ab19d" name="adaf8469daa604ad694d7edb3853ab19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf8469daa604ad694d7edb3853ab19d">&#9670;&#160;</a></span>mid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::mid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a byte vector made up of the bytes starting at <em>index</em> and for <em>length</em> bytes. If <em>length</em> is not specified it will return the bytes from <em>index</em> to the end of the vector. </p>

</div>
</div>
<a id="a42ea62629d75e7953f5b19180bb4fdc7" name="a42ea62629d75e7953f5b19180bb4fdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ea62629d75e7953f5b19180bb4fdc7">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and <em>v</em> are not equal. </p>

</div>
</div>
<a id="a299387a9e31cc2ded9ab26118fc17a82" name="a299387a9e31cc2ded9ab26118fc17a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299387a9e31cc2ded9ab26118fc17a82">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and the null terminated C string <em>s</em> do not contain the same data. </p>

</div>
</div>
<a id="ad00a9703a9536d65e0873fa31ff62035" name="ad00a9703a9536d65e0873fa31ff62035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00a9703a9536d65e0873fa31ff62035">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector that is <em>v</em> appended to this vector. </p>

</div>
</div>
<a id="a9dbc23d77c36cd60cfa79e581ac5f5ce" name="a9dbc23d77c36cd60cfa79e581ac5f5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbc23d77c36cd60cfa79e581ac5f5ce">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is less than <em>v</em>. The value of the vectors is determined by evaluating the character from left to right, and in the event one vector is a superset of the other, the size is used. </p>

</div>
</div>
<a id="ad1bd70d0ae9c72fd6e768815c612d606" name="ad1bd70d0ae9c72fd6e768815c612d606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bd70d0ae9c72fd6e768815c612d606">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a byte <em>c</em>. </p>

</div>
</div>
<a id="abd41fc03493530af75f6b5cefacc6eb1" name="abd41fc03493530af75f6b5cefacc6eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd41fc03493530af75f6b5cefacc6eb1">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a id="a7f0cc06303dbb2d22ba2809b25fd5a67" name="a7f0cc06303dbb2d22ba2809b25fd5a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0cc06303dbb2d22ba2809b25fd5a67">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <em>data</em> up to the first null byte.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if <em>data</em> is not null terminated. </dd></dl>

</div>
</div>
<a id="ad65309a009805dc8950dbf723b5110e9" name="ad65309a009805dc8950dbf723b5110e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65309a009805dc8950dbf723b5110e9">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and <em>v</em> are equal. </p>

</div>
</div>
<a id="a9ba384bab1d09d3704122a581ee3377b" name="a9ba384bab1d09d3704122a581ee3377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba384bab1d09d3704122a581ee3377b">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> and the null terminated C string <em>s</em> contain the same data. </p>

</div>
</div>
<a id="ae0ac33aa5028a1484c0f78767e295b1e" name="ae0ac33aa5028a1484c0f78767e295b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ac33aa5028a1484c0f78767e295b1e">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> is greater than <em>v</em>. </p>

</div>
</div>
<a id="a3ad53a4d1c4c910302efa00734905b91" name="a3ad53a4d1c4c910302efa00734905b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad53a4d1c4c910302efa00734905b91">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">char</a> &amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the byte at <em>index</em>. </p>

</div>
</div>
<a id="ae4aab8384d1177ef0dab15110ebc6bd7" name="ae4aab8384d1177ef0dab15110ebc6bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4aab8384d1177ef0dab15110ebc6bd7">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> &amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const reference to the byte at <em>index</em>. </p>

</div>
</div>
<a id="a01b3cc8251bedb5bbb3c917d5b30ea93" name="a01b3cc8251bedb5bbb3c917d5b30ea93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b3cc8251bedb5bbb3c917d5b30ea93">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">ReverseIterator</a> TagLib::ByteVector::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ReverseIterator that points to the front of the vector. </p>

</div>
</div>
<a id="a285911c109f6727305e2b2b3a4452051" name="a285911c109f6727305e2b2b3a4452051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285911c109f6727305e2b2b3a4452051">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">ConstReverseIterator</a> TagLib::ByteVector::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstReverseIterator that points to the front of the vector. </p>

</div>
</div>
<a id="a18a15e7cab535f22c8107992c66789d7" name="a18a15e7cab535f22c8107992c66789d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a15e7cab535f22c8107992c66789d7">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">ReverseIterator</a> TagLib::ByteVector::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ReverseIterator that points to the back of the vector. </p>

</div>
</div>
<a id="a7a912b3dee16e34975da5dce7de84965" name="a7a912b3dee16e34975da5dce7de84965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a912b3dee16e34975da5dce7de84965">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">ConstReverseIterator</a> TagLib::ByteVector::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstReverseIterator that points to the back of the vector. </p>

</div>
</div>
<a id="a95998c3e30fb62fe27f8210809f961ec" name="a95998c3e30fb62fe27f8210809f961ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95998c3e30fb62fe27f8210809f961ec">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>oldByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>newByte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces <em>oldByte</em> with <em>newByte</em> and returns a reference to the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> after the operation. This <em>does</em> modify the vector. </p>

</div>
</div>
<a id="a3503a839af29bd3d440f29c36996f38e" name="a3503a839af29bd3d440f29c36996f38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3503a839af29bd3d440f29c36996f38e">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces <em>pattern</em> with <em>with</em> and returns a reference to the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> after the operation. This <em>does</em> modify the vector. </p>

</div>
</div>
<a id="a9377cafe32051604eb1ad9c70ff5fa38" name="a9377cafe32051604eb1ad9c70ff5fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9377cafe32051604eb1ad9c70ff5fa38">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">char</a>&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize the vector to <em>size</em>. If the vector is currently less than <em>size</em>, pad the remaining spaces with <em>padding</em>. Returns a reference to the resized vector. </p>

</div>
</div>
<a id="a304d4533c8872e36edf461e03673c595" name="a304d4533c8872e36edf461e03673c595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304d4533c8872e36edf461e03673c595">&#9670;&#160;</a></span>rfind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> for <em>pattern</em> starting from either the end of the vector or <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a id="ab108f81d9b73cac51abb074403df9cf8" name="ab108f81d9b73cac51abb074403df9cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab108f81d9b73cac51abb074403df9cf8">&#9670;&#160;</a></span>setData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data for the byte array copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. </p>

</div>
</div>
<a id="aebed84d071c998033fc6fe11d99a053f" name="aebed84d071c998033fc6fe11d99a053f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebed84d071c998033fc6fe11d99a053f">&#9670;&#160;</a></span>setData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1List.html">char</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data for the byte array using the first <em>length</em> bytes of <em>s</em> </p>

</div>
</div>
<a id="abd17238daa4fad5eae1ff421e550facd" name="abd17238daa4fad5eae1ff421e550facd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd17238daa4fad5eae1ff421e550facd">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the array. </p>

</div>
</div>
<a id="ab7e2161c1153bb0e55baa21f37fd29ac" name="ab7e2161c1153bb0e55baa21f37fd29ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e2161c1153bb0e55baa21f37fd29ac">&#9670;&#160;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">bool</a> TagLib::ByteVector::startsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the vector starts with <em>pattern</em>. </p>

</div>
</div>
<a id="a078537b51e7714e1616c5fba6a1a2ecf" name="a078537b51e7714e1616c5fba6a1a2ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078537b51e7714e1616c5fba6a1a2ecf">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">void</a> TagLib::ByteVector::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exchanges the content of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> with the content of <em>v</em>. </p>

</div>
</div>
<a id="a6b42194375d3bf08131ad680b5078647" name="a6b42194375d3bf08131ad680b5078647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b42194375d3bf08131ad680b5078647">&#9670;&#160;</a></span>toBase64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::toBase64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a base64 encoded copy of the byte vector</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a258b37359217aacf0c494a192129589c">fromBase64()</a> </dd></dl>

</div>
</div>
<a id="a93f0a17258a7aeab6d9e61b211ff7816" name="a93f0a17258a7aeab6d9e61b211ff7816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f0a17258a7aeab6d9e61b211ff7816">&#9670;&#160;</a></span>toFloat32BE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">float</a> TagLib::ByteVector::toFloat32BE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 4 bytes at <em>offset</em> of the vector to a float as an IEEE754 32-bit big-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#ad8776da15f1e921a9643a4b10c39ddec">fromFloat32BE()</a> </dd></dl>

</div>
</div>
<a id="a505752b163a2896ca700fd634a0b3d25" name="a505752b163a2896ca700fd634a0b3d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505752b163a2896ca700fd634a0b3d25">&#9670;&#160;</a></span>toFloat32LE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">float</a> TagLib::ByteVector::toFloat32LE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 4 bytes at <em>offset</em> of the vector to a float as an IEEE754 32-bit little-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a75e0045d245950a0b1e73f79bc3b6f7d">fromFloat32LE()</a> </dd></dl>

</div>
</div>
<a id="ac0cfd1f2d5cf744e51301dc7fabe64c6" name="ac0cfd1f2d5cf744e51301dc7fabe64c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cfd1f2d5cf744e51301dc7fabe64c6">&#9670;&#160;</a></span>toFloat64BE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">double</a> TagLib::ByteVector::toFloat64BE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 8 bytes at <em>offset</em> of the vector to a double as an IEEE754 64-bit big-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#ab86ed6c1ddef60bd2a1b3c099fba1982">fromFloat64BE()</a> </dd></dl>

</div>
</div>
<a id="a4785d204bc4dc9276312a57452fc8d4f" name="a4785d204bc4dc9276312a57452fc8d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4785d204bc4dc9276312a57452fc8d4f">&#9670;&#160;</a></span>toFloat64LE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">double</a> TagLib::ByteVector::toFloat64LE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 8 bytes at <em>offset</em> of the vector to a double as an IEEE754 64-bit little-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a545dd80c5cff59a070b804d3d2bcc979">fromFloat64LE()</a> </dd></dl>

</div>
</div>
<a id="a049b730201793f8b55164190d43b73cc" name="a049b730201793f8b55164190d43b73cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049b730201793f8b55164190d43b73cc">&#9670;&#160;</a></span>toFloat80BE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">double</a> TagLib::ByteVector::toFloat80BE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 10 bytes at <em>offset</em> of the vector to a long double as an IEEE754 80-bit big-endian floating point number.</p>
<dl class="section note"><dt>Note</dt><dd>This may compromise the precision depending on the size of long double. </dd></dl>

</div>
</div>
<a id="a42e1f54ec6d15596bb8ea4e9231a3472" name="a42e1f54ec6d15596bb8ea4e9231a3472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e1f54ec6d15596bb8ea4e9231a3472">&#9670;&#160;</a></span>toFloat80LE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">double</a> TagLib::ByteVector::toFloat80LE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">size_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 10 bytes at <em>offset</em> of the vector to a long double as an IEEE754 80-bit little-endian floating point number.</p>
<dl class="section note"><dt>Note</dt><dd>This may compromise the precision depending on the size of long double. </dd></dl>

</div>
</div>
<a id="a3c38a1f57c66bc9ebf469335cbb0ad1b" name="a3c38a1f57c66bc9ebf469335cbb0ad1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c38a1f57c66bc9ebf469335cbb0ad1b">&#9670;&#160;</a></span>toHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::toHex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a hex-encoded copy of the byte vector. </p>

</div>
</div>
<a id="ade89536283f902a1e05624d283d63fb2" name="ade89536283f902a1e05624d283d63fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade89536283f902a1e05624d283d63fb2">&#9670;&#160;</a></span>toLongLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a> TagLib::ByteVector::toLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 8 bytes of the vector to a (signed) long long.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if <code>false</code>, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a51b81a576453f38fb816294f1e77a76d">fromLongLong()</a> </dd></dl>

</div>
</div>
<a id="a1c9fe629a10881d3d034bf6cbc3ee0d6" name="a1c9fe629a10881d3d034bf6cbc3ee0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9fe629a10881d3d034bf6cbc3ee0d6">&#9670;&#160;</a></span>toLongLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a> TagLib::ByteVector::toLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 8 bytes at <em>offset</em> of the vector to a (signed) long long.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if <code>false</code>, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a51b81a576453f38fb816294f1e77a76d">fromLongLong()</a> </dd></dl>

</div>
</div>
<a id="afd80366f7c2ec2f04c9033b411fc28fc" name="afd80366f7c2ec2f04c9033b411fc28fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd80366f7c2ec2f04c9033b411fc28fc">&#9670;&#160;</a></span>toShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">short</a> TagLib::ByteVector::toShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 2 bytes of the vector to a (signed) short.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 $01 == 0x0001 == 1, if <code>false</code>, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a id="a5c0bfaa07cf19ac9332736ec0effa007" name="a5c0bfaa07cf19ac9332736ec0effa007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0bfaa07cf19ac9332736ec0effa007">&#9670;&#160;</a></span>toShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">short</a> TagLib::ByteVector::toShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 2 bytes at <em>offset</em> of the vector to a (signed) short.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 $01 == 0x0001 == 1, if <code>false</code>, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a id="abcf244fad24bb966607e9cc418e97a99" name="abcf244fad24bb966607e9cc418e97a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf244fad24bb966607e9cc418e97a99">&#9670;&#160;</a></span>toUInt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 4 bytes of the vector to an unsigned integer.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 $00 $00 $01 == 0x00000001 == 1, if <code>false</code>, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a id="ac366a9f43958a6a5f2d627ab251d025d" name="ac366a9f43958a6a5f2d627ab251d025d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac366a9f43958a6a5f2d627ab251d025d">&#9670;&#160;</a></span>toUInt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 4 bytes at <em>offset</em> of the vector to an unsigned integer.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 $00 $00 $01 == 0x00000001 == 1, if <code>false</code>, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a id="ae477135de922ef0a5729e5b0981a1534" name="ae477135de922ef0a5729e5b0981a1534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae477135de922ef0a5729e5b0981a1534">&#9670;&#160;</a></span>toUInt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a> TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the <em>length</em> bytes at <em>offset</em> of the vector to an unsigned integer. If <em>length</em> is larger than 4, the excess is ignored.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 $00 $00 $01 == 0x00000001 == 1, if <code>false</code>, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a id="a6caf04fa53db2ae5bc851cfe1250650c" name="a6caf04fa53db2ae5bc851cfe1250650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caf04fa53db2ae5bc851cfe1250650c">&#9670;&#160;</a></span>toULongLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a> TagLib::ByteVector::toULongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 8 bytes of the vector to an unsigned long long.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if <code>false</code>, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#af0119a6cdef00b3343786f35bf1a6b7a">fromULongLong()</a> </dd></dl>

</div>
</div>
<a id="ad4b175a93fd23a2ec2eb83abebe61b8f" name="ad4b175a93fd23a2ec2eb83abebe61b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b175a93fd23a2ec2eb83abebe61b8f">&#9670;&#160;</a></span>toULongLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">long</a> <a class="el" href="classTagLib_1_1List.html">long</a> TagLib::ByteVector::toULongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 8 bytes at <em>offset</em> of the vector to an unsigned long long.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if <code>false</code>, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#af0119a6cdef00b3343786f35bf1a6b7a">fromULongLong()</a> </dd></dl>

</div>
</div>
<a id="a2a71a86707473f3a6310f6dd1cdb4f1f" name="a2a71a86707473f3a6310f6dd1cdb4f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a71a86707473f3a6310f6dd1cdb4f1f">&#9670;&#160;</a></span>toUShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">short</a> TagLib::ByteVector::toUShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 2 bytes of the vector to an unsigned short.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 $01 == 0x0001 == 1, if <code>false</code>, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a439ec22666f883d2ee2c60ab442a76b7">fromUShort()</a> </dd></dl>

</div>
</div>
<a id="af44e5b55a57e65336d068edf8fef4614" name="af44e5b55a57e65336d068edf8fef4614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44e5b55a57e65336d068edf8fef4614">&#9670;&#160;</a></span>toUShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">short</a> TagLib::ByteVector::toUShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">unsigned</a> <a class="el" href="classTagLib_1_1List.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">bool</a>&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code><a class="el" href="classTagLib_1_1List.html">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 2 bytes at <em>offset</em> of the vector to an unsigned short.</p>
<p>If <em>mostSignificantByteFirst</em> is <code>true</code> this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is <code>true</code> then $00 $01 == 0x0001 == 1, if <code>false</code>, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a439ec22666f883d2ee2c60ab442a76b7">fromUShort()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a36db251bf327d8f00dcee07367fd7cd5" name="a36db251bf327d8f00dcee07367fd7cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36db251bf327d8f00dcee07367fd7cd5">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="taglib__export_8h.html#a869a58b518ef871f14a9b4ccfe86ecfb">TAGLIB_EXPORT</a> std::ostream &amp; <a class="el" href="classTagLib_1_1List.html">operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1List.html">const</a> <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Streams the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector.">ByteVector</a> <em>v</em> to the output stream <em>s</em>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tbytevector_8h_source.html">tbytevector.h</a></li>
</ul>
</div><!-- contents -->

